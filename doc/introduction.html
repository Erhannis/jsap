<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>
  <HEAD>
    <TITLE></TITLE>

<style type="text/css">

.sidebar-left {
    float: left;
    border: solid 1px black;
}

.sidebar-right {
    float: right;
	border: solid 1px black;
}

.example-code {
	
    width: 80%;
	white-space: pre;
	background-color: #eeeeee;
	border: solid 1px black;
}

.example-caption {
}
</style>

  </HEAD>
  <BODY>

<h1>Introduction</h1> 
  
<h2>Why do we need another command line parser?</h2>

<p>Put simply, I got tired of writing simple command line parsers for every java utility program I wrote.  I would
usually just throw together something simple, requiring a certain number of arguments and deciding that args[0]
would always mean, say, an input file, and args[1] would be an output file.  It was fine for simpler utilities
with just a few parameters, but it didn't handle switches - and if I wanted anything other than a String from the
command line, I had to write that parsing into the program, too.  What annoyed me was that none of this had
anything to do with the actual task for which the utility was intended.</p>

<p>I found several parsers on the Internet, all of which handled switches, but none of which had the versatility
I wanted in terms of return types and configuration files.  Hence JSAP - the Java Simple Argument Parser.</p>

<h2>So what does JSAP actually <i>do</i>, then?</h2>

<p>JSAP not only guarantees that your command line was successfully parsed, but it instantiates objects of
types specified by the developer based upon that command line.  If you tell JSAP that one of your parameters is
an Integer, for example, and the user does not provide a String that can be converted to an Integer when invoking
the program, JSAP will throw a ParseException when you have it parse the command line.  If no exception is thrown, 
you are guaranteed an Integer when you request that parameter's value from your program.  There's a pretty big 
(and growing) list of return types suppored by JSAP; you may want to <a href="#optionparsers">skip ahead a little and check it out</a>.</p>

<div class="sidebar"><table width=200><tr><td><p>JSAP provides not only for default values for its parameters, but for an entire <i>chain</i> of defaults.  With 
a couple extra lines of code, JSAP will, for example:</p></td></tr></table></div>

<ol>
	<li>Parse the command line.</li>
	<li>For any omitted parameters, look for values in ~/.yourProgramName.conf</li>
	<li>For any <i>still</i> omitted parameters, look for values in /etc/yourProgramName.conf</li>
	<li>For any <i>still</i> omitted parameters, use the default values (if any) specified by the developer.
</ol>

<h2>Chapter 1:  Up and Running in Five Minutes.  Really.</h2>

<p>This chapter should get you up and running with JSAP very quickly.  It starts out with the most basic functionality
so you can start using it within five minutes.  We'll start with a simple example and gradually build upon 
it in order to demonstrate the various features of JSAP.</p>

<p>Everyone else begins with a "Hello, World!" program, so we will, too.</p>  

<center>
		<table width="80%" cellpadding=10 cellspacing=0 border=1>
			   <tr>
			   	   <td bgcolor="#eeeeee">
			   	   	   <pre>
public class HelloWorld_1 {

    public static void main(String[] args){
        System.out.println("Hello, World!");
    }
}</pre></td>
				</tr>
		</table>
</center>
<br>

<p>This program's output is:</p>
<center>
		<table width="80%" cellpadding=10 cellspacing=0 border=1><tr><td bgcolor="#eeeeee">
			   <pre>
> java HelloWorld_1
<b>Hello, World!</b></pre>
		  </td></tr></table>
</center>
<br>

Not only is this completely uninteresting, but it doesn't use JSAP.  Let's use JSAP to give the user a
little more control.
<br><br>
<div class="example-code">
    import com.ntpgroup.jsap.*;
	
    public static void main(String[] args) throws Exception {
        JSAP jsap = new JSAP();
        jsap.addSwitch( new Switch("verbose",'v',"verbose") );

        if( jsap.parse(args) != JSAP.CONTINUE ) System.exit(1);

        if( jsap.getBooleanValue("verbose") ) {
            System.out.print("Hello");
        } else {
            System.out.print("Hi");
        }
        
        System.out.println(", World!");
    }
</div>
<br>

Its simplest output is:
<br><br>
<center><table width="80%" cellpadding=10 cellspacing=0 border=1><tr><td bgcolor="#eeeeee"><pre>
> java HelloWorld_2
<b>Hi, World!</b>
</pre></td></tr></table></center>
<br>

But more interestingly, we can now do this:
<br><br>
<center><table width="80%" cellpadding=10 cellspacing=0 border=1><tr><td bgcolor="#eeeeee"><pre>
> java HelloWorld_2 -v
<b>Hello, World!</b>
</pre></td></tr></table></center>
<br>

...or this:
<br><br>
<center><table width="80%" cellpadding=10 cellspacing=0 border=1><tr><td bgcolor="#eeeeee"><pre>
> java HelloWorld_2 --verbose
<b>Hello, World!</b>
</pre></td></tr></table></center>
<br>

Let's look at the main() method more closely to see what's happening:<br><br>

First, we'll just create the JSAP object we'll use to do the parsing.
<br><br>        
<center><table width="80%" cellpadding=10 cellspacing=0 border=1><tr><td bgcolor="#eeeeee"><pre>
JSAP jsap = new JSAP();
</pre></td></tr></table></center>
<br>
Next, we tell the JSAP object to expect a switch.  The switch is just the "-v" or "--verbose" you saw
above.  The first parameter in the Switch constructor is the case-sensitive ID we'll use internally to access its
value.  The second parameter is its "short name", the single-character version of the switch which is
used by prefacing it with one hyphen on the command line.  The third parameter is its "long name", which 
is used by prefacing it with two hyphens on the command line.
<br><br>

<center><table width="80%" cellpadding=10 cellspacing=0 border=1><tr><td bgcolor="#eeeeee"><pre>
jsap.addSwitch( new Switch("verbose",'v',"verbose") );
</pre></td></tr></table></center>
<br>

Next, we have our JSAP object parse the arguments our main() method received.  If its return value is
JSAP.CONTINUE, the command line was parsed successfully and we can continue with our program.
<br><br>

<center><table width="80%" cellpadding=10 cellspacing=0 border=1><tr><td bgcolor="#eeeeee"><pre>
if( jsap.parse(args) != JSAP.CONTINUE ) System.exit(1);
</pre></td></tr></table></center>
<br>

Now we can print our message.  We first determine whether the "verbose" switch is set.  We do this by
calling getBooleanValue(ID) on our JSAP object.  If it's true, the switch was specified on the command
line.
<br><br>        
<center><table width="80%" cellpadding=10 cellspacing=0 border=1><tr><td bgcolor="#eeeeee"><pre>
if( jsap.getBooleanValue("verbose") ) {
	System.out.print("Hello");
} else {
	System.out.print("Hi");
}
       
System.out.println(", World!");
</pre></td></tr></table></center>
<br>

That's it.  Switches are pretty easy to use.  Now let's make it even more interesting by allowing the
user to specify how many times to print the message.
<br><br>
<center><table width="80%" cellpadding=10 cellspacing=0 border=1><tr><td bgcolor="#eeeeee"><pre>
public static void main(String[] args) throws Exception {
    JSAP jsap = new JSAP();
    jsap.addSwitch( new Switch("verbose",'v',"verbose") );
    jsap.addOption( new IntegerOption("hellocount",'n',JSAP.NO_LONGNAME,"1",true) );

    if( jsap.parse(args) != JSAP.CONTINUE ) System.exit(1);

    for(int i=0; i&lt;jsap.getIntValue("hellocount"); ++i){
        if( jsap.getBooleanValue("verbose") ) {
            System.out.print("Hello");
        } else {
            System.out.print("Hi");
        }
        System.out.println(", World!");
    }        
}
</pre></td></tr></table></center>
<br>

Here's some of the output of this program:
<br><br>
<center><table width="80%" cellpadding=10 cellspacing=0 border=1><tr><td bgcolor="#eeeeee"><pre>
>java HelloWorld_3
<b>Hi, World!</b>

>java HelloWorld_3 -v
<b>Hello, World!</b>

>java HelloWorld_3 -v -n 3
<b>Hello, World!
Hello, World!
Hello, World!</b>

>java HelloWorld_3 -n 4 --verbose
<b>Hello, World!
Hello, World!
Hello, World!
Hello, World!</b>
</pre></td></tr></table></center>
<br>
You'll find that the source code for this program is nearly identical to that of the last version of our 
program.  Let's focus on the new additions.
<br><br>
The following tells our JSAP object to recognize a command-line Option.  It's an IntegerOption, so the user must
specify an integer as its value.  We've given it the ID of "hellocount", and a short name of 'n', but
no long name at all.  Its default value is "1", which is passed as a String (for reasons that will be
made clear later in this manual), and it is declared to be a required parameter, although this is irrelevant
because we provided a default value (i.e., if the user does not supply a value, the default will be used,
so this "required" option will always be defined).
<br><br>
<center><table width="80%" cellpadding=10 cellspacing=0 border=1><tr><td bgcolor="#eeeeee"><pre>
        jsap.addOption( new IntegerOption("hellocount",'n',JSAP.NO_LONGNAME,"1",true) );
</pre></td></tr></table></center>
<br>

The upper limit in the following loop is the integer that was specified on the command line, which is
retrieved by calling JSAP.getIntValue(ID) with the ID we used to create the Option.  Note that we don't
need to make sure the value is an int -- JSAP has already assured us of this by returning JSAP.CONTINUE
from its parse() method.
<br><br>
<center><table width="80%" cellpadding=10 cellspacing=0 border=1><tr><td bgcolor="#eeeeee"><pre>
        for(int i=0; i<jsap.getIntValue("hellocount"); ++i){
            if( jsap.getBooleanValue("verbose") ) {
                System.out.print("Hello");
            } else {
                System.out.print("Hi");
            }
            System.out.println(", World!");
        }        
</pre></td></tr></table></center>
<br>

We're almost ready to use JSAP in our own applications; there's just one more thing to see, called an
UnflaggedOption.  This is an option, similar to the "hellocount" we used above, that is not preceded
by a hyphenated name.  You can have as many UnflaggedOptions as you like, allowing you to have a
command line syntax like "programname inputfile outputfile", and the UnflaggedOptions will be processed
in the order in which they are added to the JSAP object.  We'll use one to specify the user's name.  If
it's not provided by the user, we'll still use the word "World".
<br><br>
<center><table width="80%" cellpadding=10 cellspacing=0 border=1><tr><td bgcolor="#eeeeee"><pre>
import com.ntpgroup.jsap.*;

public class HelloWorld_4 {

    public static void main(String[] args) throws Exception {
        JSAP jsap = new JSAP();
        jsap.addSwitch( new Switch("verbose",'v',"verbose") );
        jsap.addOption( new IntegerOption("hellocount",'n',JSAP.NO_LONGNAME,"1",true) );
        jsap.addUnflaggedOption( 
            new StringOption("username", JSAP.NO_SHORTNAME, JSAP.NO_LONGNAME, "World", true), false );

        if( jsap.parse(args) != JSAP.CONTINUE ) System.exit(1);

        for(int i=0; i&lt;jsap.getIntValue("hellocount"); ++i){
            if( jsap.getBooleanValue("verbose") ) {
                System.out.print("Hello");
            } else {
                System.out.print("Hi");
            }
            System.out.println(", " + jsap.getString("username") + "!");
        }        
    }

}
</pre></td></tr></table></center>
<br>

Some of this program's output is:

<br><br>
<center><table width="80%" cellpadding=10 cellspacing=0 border=1><tr><td bgcolor="#eeeeee"><pre>
>java HelloWorld_4 -v -n 3
<b>Hello, World!
Hello, World!
Hello, World!</b>

>java HelloWorld_4 -v -n 3 Marty
<b>Hello, Marty!
Hello, Marty!
Hello, Marty!</b>

>java HelloWorld_4 Marty
<b>Hi, Marty!</b>

>java HelloWorld_4 Marty -n 2
<b>Hi, Marty!
Hi, Marty!</b>
</pre></td></tr></table></center>
<br>

It's that simple.  Of course, there's a lot more JSAP can do, but this is enough to start using it.  Try
the sample programs above - and try giving them unexpected input, like "-n foo" or "-n 5 -z".  You'll see
that using JSAP will allow you to focus on the real program at hand rather than the invocation of the
program.
<br><br>
The following table lists the built-in Option types and the JSAP shortcut methods for retrieving their 
values.  You can also create your own Option types.
<br><br>
<center><table cellpadding=10 border=1 cellspacing=0>
<tr><td><b>Option Type</b></td><td><b>JSAP Accessors</b></td></tr>
<tr><td>StringOption</td><td>String JSAP.getString(String id)</td></tr>
<tr><td>IntegerOption</td><td>int JSAP.getIntValue(String id)<br>Integer JSAP.getInteger(String id)</td></tr>
<tr><td>InetAddressOption</td><td>InetAddress JSAP.getInetAddress(String id)</td></tr>
<tr><td>URLOption</td><td>URL JSAP.getURL(String id)</td></tr>
<tr><td>Switch / BooleanOption</td><td>boolean JSAP.getBooleanValue(String id)<br>Boolean JSAP.getBoolean(String id)</td></tr>
</table>

<!--

  Terms:

  Argument:  a single token from the command line

  Option:   a token or combination of tokens that provide the program with a single unit of information.

  Value:    the information provided by the user in an Option

  Flagged Option:    an value preceded by a flag (beginning with one or two hyphens) that identifies the option (e.g. "-f somefilename" or "--file somefilename")

  Unflagged Option:  an value NOT preceded by a flag, identified only by the order in which it is provided by the user

  Switch:   a Tagged Option with an implicit value of "true" when specified (e.g. "-r" to indicate recursive)

-->
  </BODY>
</HTML>
