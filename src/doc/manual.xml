<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
<book>
  <title>JSAP - Java Simple Argument Parser</title>

  <chapter>
    <title>Introduction</title>

    <sect1>
      <title>Why did you write another command line parser?</title>

      <para>Put simply, I got tired of writing simple command line parsers for
      every java utility program I wrote. I wanted a simple tool that would
      support complex command lines - and return more than just Strings. If
      one of the options for a program, for example, is a number, it should be
      retrievable by the program AS a number. JSAP does this, and allows
      developers to add new command line data types as needed.</para>

      <para>I also wanted the ability to read default values from a
      configuration file, which could be overridden by the command line. JSAP
      supports this, and in fact supports multiple, &#34;cascading&#34;
      configuration files as well.</para>
    </sect1>

    <sect1>
      <title>So what does JSAP actually do?</title>

      <para>JSAP parses your command line and instantiates objects of types
      you specify based upon that command line. If you configure JSAP to
      expect an Integer on the command line, and the user does not provide a
      String that can be converted to an Integer, JSAP will alert your program
      to the fact that there was a problem with the command line. If JSAP
      indicates that your command line was successfully parsed, you are
      guaranteed an Integer when you request that parameter&#39;s value from
      your program. There&#39;s a pretty big (and growing) list of return
      types suppored by JSAP; you may want to skip ahead a little and check it
      out.</para>

      <para>JSAP provides not only for default values for its parameters, but
      for a cascading chain of values. With a couple extra lines of code, JSAP
      will, for example:</para>

      <procedure>
        <step>
          <para>Parse the command line.</para>
        </step>

        <step>
          <para>For any omitted parameters, look for values in
          ~/.yourProgramName.conf</para>
        </step>

        <step>
          <para>For any still omitted parameters, look for values in
          /etc/yourProgramName.conf</para>
        </step>

        <step>
          <para>For any still omitted parameters, use the default values (if
          any) specified by the developer.</para>
        </step>
      </procedure>
    </sect1>
  </chapter>

  <chapter>
    <title>Vocabulary</title>

    <para>Before continuing, some explanation of the vocabulary used in this
    manual is required:</para>

    <variablelist>
      <varlistentry>
        <term>Argument</term>

        <listitem>
          <para>A single (String) token from the command line. The JVM will
          provide an array of these to your main() method.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Parameter</term>

        <listitem>
          <para>One or more arguments that must be taken together to have
          meaning. For example, in the command &#34;java -cp myjar.jar
          MyClass&#34;, the arguments &#34;-cp&#34; and &#34;myjar.jar&#34;
          comprise a single parameter defining the classpath. The argument
          &#34;MyClass&#34; comprises another parameter indicating the class
          to load and run.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Switch</term>

        <listitem>
          <para>A single-argument parameter whose presence alone conveys
          meaning. For example, in the command &#34;java -version&#34;, the
          &#34;-version&#34; switch tells the JVM to print its version
          information and exit.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Option</term>

        <listitem>
          <para>A parameter whose content conveys meaning. In the command
          &#34;java -cp myjar.jar MyClass&#34;, the &#34;-cp myjar.jar&#34;
          parameter is an option, as is the &#34;MyClass&#34; parameter.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Flagged Option</term>

        <listitem>
          <para>An option that is preceded by a &#34;flag&#34; to indicate
          which option is being set. In the command &#34;java -cp myjar.jar
          MyClass&#34;, the &#34;-cp myjar.jar&#34; option is flagged by
          &#34;-cp&#34;.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Unflagged Option</term>

        <listitem>
          <para>An option that is not preceded by a flag, and whose meaning is
          conveyed by its position in the command line relative to other
          Unflagged Options. In the command &#34;java -cp myjar.jar
          MyClass&#34;, &#34;MyClass&#34; is an unflagged option.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Short Flag</term>

        <listitem>
          <para>A single-character flag preceded by a single dash.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Long Flag</term>

        <listitem>
          <para>A multi-character flag preceded by a double dash.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>ID</term>

        <listitem>
          <para>A unique identifier assigned by the programmer to each
          parameter JSAP should recognize. A parameter&#39;s ID is seen only
          by the programmer, and is used to retrieve its values from the
          JSAPResult object.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </chapter>

  <chapter>
    <title>Quick Start</title>

    <para>If you&#39;re the type of developer who likes to take a quick look
    at example code and tweak it for your needs, this chapter should get you
    up and running with JSAP very quickly. We&#39;ll start with a simple
    example and gradually build upon it in order to demonstrate some of the
    basic features of JSAP. You&#39;ll have to read further for some of the
    more interesting features.</para>

    <sect1>
      <title>HelloWorld_1</title>

      <para>Everyone else begins with a &#34;Hello, World!&#34; program, so we
      will, too.</para>

      <programlisting>@@Manual_HelloWorld_1@@</programlisting>

      <screen>${run:java com.martiansoftware.jsap.examples.HelloWorld_1}
<prompt>[mlamb@morbo]</prompt><command>this is my command
<computeroutput>this is the computer output</computeroutput></command></screen>

      <para>Not only is this completely uninteresting, but it doesn&#39;t use
      JSAP. Let&#39;s tweak it a little.</para>
    </sect1>

    <sect1>
      <title>HelloWorld_2</title>

      <programlisting>@@Manual_HelloWorld_2@@</programlisting>

      <para>That&#39;s pretty verbose. Later on you&#39;ll see ways to trim
      this down quite a bit. Here&#39;s what&#39;s going on:</para>

      <procedure>
        <step>
          <para>We create a new JSAP to do the parsing.</para>
        </step>

        <step>
          <para>We create a new flagged option so we can tell the program how
          many times to print the message.</para>

          <procedure>
            <step>
              <para>It has an ID of &#34;count&#34;, which is only used
              internally by our program to retrieve the value.</para>
            </step>

            <step>
              <para>It&#39;s using an IntegerStringParser to convert the value
              to an Integer, and it has a default value of 1.</para>
            </step>

            <step>
              <para>It&#39;s required, but since we&#39;re specifying a
              default value, the requirement will always be met.</para>
            </step>

            <step>
              <para>It has a short flag &#34;n&#34;, so the syntax is &#34;-n
              5&#34; to print the message five times, for example.</para>
            </step>

            <step>
              <para>It has no long flag.</para>
            </step>
          </procedure>
        </step>

        <step>
          <para>We register the flagged option with the parser we created in
          the beginning.</para>
        </step>

        <step>
          <para>We tell the parser to parse the command line arguments, and
          store the result in a variable called &#34;config&#34;.</para>
        </step>

        <step>
          <para>We print the message.</para>
        </step>
      </procedure>

      <para>The output of the program looks like this:</para>

      <screen>${run:java com.martiansoftware.jsap.examples.HelloWorld_2}

${run:java com.martiansoftware.jsap.examples.HelloWorld_2 -n 5}</screen>

      <para>So far, so good. Let&#39;s add a switch.</para>
    </sect1>

    <sect1>
      <title>HelloWorld_3</title>

      <programlisting>@@Manual_HelloWorld_3@@</programlisting>

      <para>What did we do? We created a new &#34;switch&#34; to determine how
      verbose we&#39;re going to be with our greeting, registered it with
      JSAP, and read its value inside the print loop. That might still seem
      like a lot of code for this little feature, but let&#39;s look at all
      the ways we can invoke the program now:</para>

      <screen>${run:java com.martiansoftware.jsap.examples.HelloWorld_3 -n 2}

${run:java com.martiansoftware.jsap.examples.HelloWorld_3 -n 3 -v}

${run:java com.martiansoftware.jsap.examples.HelloWorld_3 --verbose}

${run:java com.martiansoftware.jsap.examples.HelloWorld_3 -vn 2}</screen>

      <para>That last one is the most interesting - note that we were able to
      combine multiple short flags (&#34;v&#34; and &#34;n&#34;). JSAP allows
      this for as many short flags as you want - provided that at most one of
      them is an option (as opposed to a switch) and it&#39;s the last one in
      the list.</para>

      <para>For the next example, we&#39;ll use an unflagged option to specify
      to whom we really want to say hello. It will be optional, defaulting to
      &#34;World&#34; for backwards compatibility with our earlier examples.
      :) We&#39;ll also make it greedy, so it consumes the rest of the command
      line to allow multiple values.</para>
    </sect1>

    <sect1>
      <title>HelloWorld_4</title>

      <para>Here we&#39;ve added an UnflaggedOption to greet specific names.
      It&#39;s marked as &#34;greedy&#34;, so any number of names on the
      command line are associated with this option.</para>

      <programlisting>@@Manual_HelloWorld_4@@</programlisting>

      <screen>${run:java com.martiansoftware.jsap.examples.HelloWorld_4 -n 2 --verbose Bender Fry Leela}

${run:java com.martiansoftware.jsap.examples.HelloWorld_4 Kif -n 3}

${run:java com.martiansoftware.jsap.examples.HelloWorld_4 -v -n 2}</screen>
    </sect1>

    <sect1>
      <title>HelloWorld_5</title>

      <para>All or the previous examples showed command lines flawlessly typed
      by the user. This, of course, never happens. One way to handle this is
      to print usage information:</para>

      <programlisting>@@Manual_HelloWorld_5@@</programlisting>

      <screen>${run:java com.martiansoftware.jsap.examples.HelloWorld_5 -n 2 -n 4}

${run:java com.martiansoftware.jsap.examples.HelloWorld_5 --nosuchflag}</screen>
    </sect1>

    <sect1>
      <title>HelloWorld_6</title>

      <para>Of course, sometimes usage information doesn&#39;t provide enough
      detail. How about some actual program help?</para>

      <programlisting>@@Manual_HelloWorld_6@@</programlisting>

      <screen>${run:java com.martiansoftware.jsap.examples.HelloWorld_5 -n 2 -n 4}

${run:java com.martiansoftware.jsap.examples.HelloWorld_5 --nosuchflag}</screen>

      <para>In HelloWorld_3 you learned how to add a switch (verbose). Combine
      a -h / --help switch with the getHelp() method as used here, and
      you&#39;ve made your program much friendlier.</para>
    </sect1>

    <sect1>
      <title>HelloWorld_7</title>

      <para>Showing the expected input of your program can be helpful, but it
      can be even more helpful to tell the user specifically what they did
      wrong. It&#39;s pretty easy:</para>

      <programlisting>@@Manual_HelloWorld_7@@</programlisting>

      <screen>${run:java com.martiansoftware.jsap.examples.HelloWorld_5 -n 2 -n 4}

${run:java com.martiansoftware.jsap.examples.HelloWorld_5 --nosuchflag}</screen>
    </sect1>
  </chapter>

  <chapter>
    <title>How It Works</title>

    <para>Everything you do with JSAP leads to the same goal: a JSAPResult
    object that contains objects created from the parsed command line. Getting
    to this point requires the following steps:</para>

    <sect1>
      <title>Creating a JSAP to do the parsing.</title>

      <para>This is generally accomplished through JSAP&#39;s no-argument
      constructor. Depending upon the complexity of your program, however, you
      may want to instantiate a custom JSAP subclass that also takes care of
      steps 2 and 3 (described below) during the construction process. This
      approach results in a much &#34;cleaner&#34; main class.</para>
    </sect1>

    <sect1>
      <title>Defining your program&#39;s parameters.</title>

      <para>As described above in the Vocabulary section, there are three
      types of parameters you can define: Switches, FlaggedOptions, and
      UnflaggedOptions. When you define a parameter, you tell JSAP what flags
      (if any) it uses, what its default values are, whether it is required,
      what its ID is, and other relevant information. See the individual
      sections below for each type of parameter for details.</para>
    </sect1>

    <sect1>
      <title>Registering your parameters with JSAP.</title>

      <para>Each parameter you define must be registered with JSAP via its
      registerParameter method. When a parameter is registered, its properties
      (flags, etc.) cannot be modified; to modify them, you must first
      unregister them from JSAP, and register them again once modified.
      Registration can throw an exception if the parameter to be registered
      conflicts with any other registered parameters (for example, if they use
      the same flags, or have the same ID).</para>
    </sect1>

    <sect1>
      <title>Parsing the command line.</title>

      <para>The JSAP object provides two parse() methods to parse a command
      line. The first takes an array of Strings as its only parameter; in most
      uses of JSAP, this will simply be the args[] array supplied by the JVM
      to your main() method.</para>

      <para>The second parse() method takes a single String as its only
      parameter. This method first tokenizes the String into an array, much
      like the operating system does for the JVM in providing your main()
      method with the args[] array, then calls the parse(String[]) method
      described above.</para>

      <para>Both of these methods return a JSAPResult object encapsulating the
      parsed command line.</para>
    </sect1>

    <sect1>
      <title>Using the JSAPResult</title>

      <para>The result of JSAP.parse() is a JSAPResult object. This contains
      all of the values for each command line parameter. There are a large
      number of accessor methods available for reading the values:
      getString(), getBoolean(), getInteger(), getInetAddress(), getColor(),
      ...far too many to include here, including Iterators and arrays for
      reading multivalue parameters. The javadocs are pretty useful for this
      class.</para>
    </sect1>
  </chapter>

  <chapter>
    <title>Short vs. Long Flags</title>

    <para>Both switches and flagged options require flags. Flags can be short,
    consisting of a single character and preceded by a single hyphen, or long,
    consisting of more than one character and preceded by two hyphens.
    Switches and flagged options may use short flags, long flags, or both.</para>

    <para>In general, your program&#39;s most commonly used options should
    have short flags. Long flags are generally more appropriate for
    less-frequently used options.</para>

    <para>In order to configure a parameter with no short flag, specify a
    short flag equal to JSAP.NO_SHORTFLAG. In order to configure a parameter
    with no long flag, specify a long flag equal to JSAP.NO_LONGFLAG.</para>
  </chapter>

  <chapter>
    <title>Switches</title>

    <para>A Switch is just what it sounds like: a setting that is either on or
    off. If a switch is present on the command line,
    JSAPResult.getBoolean(&#34;yourSwitchID&#34;) will return true. Otherwise,
    it will return false.</para>
  </chapter>

  <chapter>
    <title>Flagged Options</title>

    <para>A Flagged Option is a value preceded by either a long or short flag
    indicating the value&#39;s meaning (see the example in Chapter 2). The
    FlaggedOption class provides a setAllowMultipleDeclarations(boolean)
    method that informs JSAP whether the FlaggedOption may be repeated on the
    command line. For example, if your program uses a FlaggedOption to specify
    an input file (say, &#34;-i file&#34;), multiple declarations will allow
    your users to enter &#34;-i file1 -i file2 -i file3 ...&#34;. The multiple
    values can be accessed through JSAPResult&#39;s getXXXArray() methods.</para>
  </chapter>

  <chapter>
    <title>Unflagged Options</title>

    <para>Unflagged Options are values whose meanings are indicated by their
    position on the command line relative to other Unflagged Options (see
    example in Chapter 2). JSAP expects Unflagged Options on the command line
    in the order in which they were registered with the JSAP.</para>

    <para>&#34;Greedy&#34; Unflagged Options (set via
    UnflaggedOption.setGreedy(boolean)) consume all remaining unflagged values
    from the command line as multiple values. Obviously, your JSAP can have
    only one greedy Unflagged Option, and it must be the last Unflagged Option
    registered with the JSAP.</para>
  </chapter>

  <chapter>
    <title>StringParsers</title>

    <para>All String-to-Object conversions are handled by StringParsers. The
    type of Object you want to read from the command line determines which
    StringParser you should use with your Option. If you need an int, use
    IntegerStringParser. If you need an InetAddress, use
    InetAddressStringParser. JSAP comes with quite a few - see the
    com.martiansoftware.jsap.stringparsers package.</para>

    <para>Of course, you may want to read your own object types from the
    command line, or at least read a type that JSAP doesn&#39;t support out of
    the box. No problem. Just extend com.martiansoftware.jsap.StringParser.
    The only method you have to implement is:</para>

    <programlisting>public abstract Object parse(String arg) throws com.martiansoftware.jsap.ParseException;</programlisting>

    <para>You can now use your own StringParser with any JSAP option. JSAP
    won&#39;t have a built-in accessor method for the class of the object
    you&#39;re returning, so you&#39;ll have to use JSAPResult.getObject() or
    JSAPResult.getObjectArray() and re-cast the result to obtain the objects.</para>
  </chapter>

  <chapter>
    <title>Handling Errors</title>

    <para>Users can botch program input in more ways than you could ever
    imagine. To detect an error, check JSAPResult.success() after parsing the
    command line. It will return false if there were any problems.</para>

    <para>Once you detect a problem, you have a number of options:</para>

    <itemizedlist>
      <listitem>
        <para>Display program usage (see HelloWorld_5 example)</para>
      </listitem>

      <listitem>
        <para>Display help information (see HelloWorld_6 example)</para>
      </listitem>

      <listitem>
        <para>Display messages specific to the user&#39;s errors (see
        HelloWorld_7 example)</para>
      </listitem>

      <listitem>
        <para>Obtain a list of parameter IDs for the problematic items through
        JSAPResult.getBadParameterIDIterator(). Then obtain the individual
        exceptions for each ID through JSAPResult.getExceptionIterator(String
        id) and related methods. After that, you&#39;re on your own.</para>
      </listitem>

      <listitem>
        <para>Any combination of the above.</para>
      </listitem>
    </itemizedlist>
  </chapter>

  <chapter>
    <title>DefaultSources and Configuration Files</title>

    <para>Default program behavior can be configured in one or more files that
    the command line merely overrides. JSAP provides a
    registerDefaultSource(DefaultSource) method to support this. At the time
    of this writing, the only concrete implementation of DefaultSource is
    PropertyDefaultSource, which reads files in java.util.Properties format.</para>

    <para>Multiple DefaultSources may be registered with a JSAP. When a
    default value is sought, the DefaultSources are checked in the order in
    which they were registered. The first default value encountered by JSAP is
    used.</para>

    <para>Yes, it&#39;s implemented through JSAP.registerDefaultSource().
    Defaultsare checked in the order in which they are registered with the
    JSAP.Right now the only type of DefaultSource implemented is based
    onProperty files. When you create the PropertyDefaultSource, however,
    youcan specify whether or not it should throw exceptions for problems
    suchas the property file not existing. If you tell it to ignore
    exceptions,you can make this work across platforms.For example, you might
    want to check your user&#39;s home directory first. You can obtain the
    users&#39; home directory through the System properties,so this would work
    cross-platform right away (you would of course needto append
    File.separator and the name of the file you&#39;re looking for). This
    would be the first DefaultSource you register.Then you might want to
    register /etc/yourprogram.conf as a source. Thiswill just be ignored on
    Windows if you tell this DefaultSource not tothrow exceptions.Then you
    might want to use the &#34;All Users&#34; directory on Windows, so youcan
    get the user&#39;s home again, then use File operations to
    obtain&#34;..\\All Users\\yourprogram.conf&#34; and register yet another
    source.Note that the order in which these last two are done doesn&#39;t
    matter; oneither linux or Windows, at least one of them will be
    ignored.There&#39;s no automatic checking of any location; it&#39;s up to
    the developerto provide the list of places to check. That might be a nice
    thing toadd to the TO DO list</para>

    <sect1>
      <title>PropertyDefaultSource</title>

      <para>PropertyDefaultSource reads default values from text files
      consisting of zero or more lines of &#34;key=value&#34;-type
      assignments. Property names may be parameter IDs, long flags, or short
      flags for the parameters they address. JSAP interprets them in that
      order (ID, then long flag, then short flag).</para>

      <para>When you create a PropertyDefaultSource, you can tell it not to
      throw Exceptions. This allows you to specify a number of possible
      locations for files that don&#39;t have to exist.</para>

      <para>A typical order in which to register PropertyDefaultSources is:<orderedlist><listitem><para>.yourprogramname
      in the user&#39;s home directory (obtained via System properties)</para></listitem><listitem><para>/etc/yourprogramname.conf
      on *nix systems</para></listitem><listitem><para>$YOURPROGRAM_HOME/yourprogramname.conf
      if your program makes use of an environment variable to point to its
      home directory</para></listitem></orderedlist></para>

      <para>Note: if anyone has suggestions for a search order example for
      Windows or Mac, please let me know.</para>
    </sect1>
  </chapter>

  <chapter>
    <title>Using ANT To Make Everything Easier</title>

    <para>The Ant task is still experimental. It used to work quite well, but
    it hasn&#39;t kept up with recent changes. It&#39;s on my list.</para>
  </chapter>

  <chapter>
    <title>Reporting Problems</title>

    <para>Please send any problem reports to jsap at martiansoftware dot com.</para>
  </chapter>
</book>